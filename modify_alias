#!/usr/bin/env python3
import argparse
from typing import Sequence
from subprocess import Popen, PIPE, run, DEVNULL
import os
import time

import zmq

class InteractiveAliasAnalysisDriver:
    args: argparse.Namespace
    """
    The argument parsers namespace which holds the parsed commandline
    attributes.
    """

    def register_all_arguments(self,
                               arg_parser: argparse.ArgumentParser) -> None:
        """
        Registers all the command line arguments that are used by this tool.

        Add other/additional arguments by overloading this function.
        """
        arg_parser.add_argument("input_file",
                                type=str,
                                nargs="?",
                                help="path to input file")

        arg_parser.add_argument(
            "-op",
            "--optpath",
            type=str,
            help="full path to the opt binary",
            default="/home/michel/ETH/AST/llvm-project/build_interact/bin/opt")

        arg_parser.add_argument(
            "-cp",
            "--compilerpath",
            type=str,
            help="full path to the compiler binary (needs to understand LLVM IR)",
            default="/home/michel/ETH/AST/llvm-project/build_ast/bin/clang")

        arg_parser.add_argument("-csmith",
                                help="Use if the file is generated by csmith",
                                action='store_true')

    def __init__(self, args: Sequence[str] | None = None):

        # arg handling
        arg_parser = argparse.ArgumentParser()
        self.register_all_arguments(arg_parser)
        self.args = arg_parser.parse_args(args=args)

        context = zmq.Context()
        self.socket = context.socket(zmq.REP)
        self.socket.bind("tcp://*:5555")



    def run(self) -> None:
        """
        Runs the tool.
        """
        #self.measure_all_modification_style(substitutions={
        #    "NoAlias": 3,
        #    "MustAlias": 3,
        #    "PartialAlias": 3,
        #    "MayAlias": 3,
        #})
        self.replace_single_query(3, 3)
        # self.compile_spec()

    def compile_spec(self) -> None:
        """
        Compiles the spec benchmark.
        """

        my_env = os.environ.copy()
        my_env["CC"] = self.args.compilerpath
        my_env["CXX"] = self.args.compilerpath + "++"
        cmd = (
            "cmake .. -G Ninja -DCMAKE_CXX_FLAGS=\"-Os\" -DCMAKE_C_FLAGS=\"-Os\" -DCMAKE_C_COMPILER=" + self.args.compilerpath + " -DCMAKE_CXX_COMPILER="  + self.args.compilerpath + "++"
        ).split(" ")
        print(cmd)
        run(cmd, stdin=PIPE, stdout=PIPE, text=True, env=my_env, cwd="../specbuilder/build_python")
        p = Popen("ninja", stdin=PIPE, stdout=PIPE, text=True, env=my_env, cwd="../specbuilder/build_python")

        substitutions = {
             "NoAlias": 3,
             "MustAlias": 3,
             "PartialAlias": 3,
             "MayAlias": 3,
        }

        line = p.stdout.readline().strip()
        index = 0
        while not line.startswith("; ModuleID"):
            index = index + 1
            if index % 10 == 0:
                print("Modifying " + str(index))

            if line.startswith("["):
                line = p.stdout.readline().strip()
                continue

            print(line)
            if line.startswith("Failed"):
                return False


            curr_result = self.get_result_from_output(line)
            # print("Replacing " + curr_result + " with " + str(substitutions[curr_result]))
            p.stdin.write(str(substitutions[curr_result]) + "\n")

            p.stdin.flush()
            line = p.stdout.readline().strip()


    # Replaces to_replace with replacement
    def replace_single_query(self, to_replace: int, replacement: int) -> bool:
        self.measure_single_modification_style(
            to_replace,
            modification_callback=lambda cmd, index: self.
            execute_with_modifications(cmd, index, replacement))

    # Measures the map all occurences style.
    def measure_all_modification_style(self, substitutions: dict[str, int]):
        self.get_ll_file(self.args.compilerpath, self.args.input_file)

        cmd = [self.args.optpath, '-Os', 'csmith/file2.ll', '-S']

        count = self.get_count_of_queries(cmd, "NoAlias")

        print("count is " + str(count))

        self.compile_with_substitutions(cmd, substitutions,
                                        "files_sache/file0.ll")

        print("Done with modifications")

        # Compile groundtruth
        compile_cmd = [
            self.args.compilerpath, 'files_sache/truth.ll', '-o',
            "files_sache/truth.out"
        ]
        print(compile_cmd)
        run(compile_cmd, stdout=DEVNULL, stderr=DEVNULL, text=True)

        if not self.compile_file(0):
            print("Compilation failed for modified")

        print("Done with compilation")

        # Measure groundtruth
        true_size = self.measure_outputsize("files_sache/truth.out")
        print("True size is " + str(true_size))

        size = self.measure_outputsize("files_sache/file0.out")
        if size == -1:
            print("Size measurement failed for modified")
        print("new size: " + str(size))

    # Measures the nth occurence replacement style.
    def measure_single_modification_style(self, to_replace: int,
                                          modification_callback):
        self.get_ll_file(self.args.compilerpath, self.args.input_file)

        cmd = [self.args.optpath, '-Os', 'csmith/file2.ll', '-S']

        count = self.get_count_of_queries(cmd, to_replace)

        print("Count is " + str(count))

        for i in range(count):
            if i % 10 == 0:
                print("Modifying " + str(i))
            if not modification_callback(cmd, i):
                print("Modification failed for " + str(i))

        print("Done with modifications")

        # Compile groundtruth
        run([
            self.args.compilerpath, 'files_sache/truth.ll', '-o',
            "files_sache/truth.out"
        ],
            stdout=DEVNULL,
            stderr=DEVNULL,
            text=True)

        for i in range(count):
            if i % 10 == 0:
                print("Compiling " + str(i))
            if not self.compile_file(i):
                print("Compilation failed for " + str(i))

        print("Done with compilation")

        # Measure groundtruth
        true_size = self.measure_outputsize("files_sache/truth.out")
        print("True size is " + str(true_size))

        for i in range(count):
            size = self.measure_outputsize("files_sache/file" + str(i) +
                                           ".out")
            if size == -1:
                print("Size measurement failed for " + str(i))
            elif size != true_size:
                print(str(i) + ": " + str(size))

    # Runs the given compile command mapping AliasResults through substitutions
    #
    # Returns true if the modification was successful
    def compile_with_substitutions(self, cmd: list[str],
                                   substitutions: dict[str, int],
                                   output_file_name: str) -> bool:
        print(cmd + [" substitutions!"])
        p = Popen(cmd, stdin=PIPE, stdout=PIPE, text=True)

        while True:
            #  Wait for next request from client
            message = self.socket.recv()
            print(f"Received request: {message}")

            #  Send reply back to client
            self.socket.send_string(substitutions[message])

        output_file = open(output_file_name, 'w')
        while line != "":
            line = p.stdout.readline()
            output_file.write(line)

        return True

    # Uses the given compiler get the .ll file in csmith/file2.ll for the given
    # input file
    def get_ll_file(self, compiler_path: str, input_file: str) -> None:
        cmd = compiler_path + " -S -emit-llvm -Xclang -disable-llvm-passes -o csmith/file2.ll " + input_file + " -O1" + (
            " -I/usr/include/csmith-2.3.0" if self.args.csmith else "")
        print(cmd)
        run(cmd.split(" "), stdout=DEVNULL, stderr=DEVNULL, text=True)

    # Given a command that runs opt, returns the number of queries with
    # to_replace as result
    #
    # Returns -1 if the command or an input fails Write result into
    # `files_sache/truth.ll`
    def get_count_of_queries(self, cmd: list[str], to_replace: int) -> int:

        print(cmd + [" counting!"])
        p = Popen(cmd, stdin=PIPE, stdout=PIPE, text=True)
        count = 0

        while p.poll() is None:

            try:
                #  Wait for next request from client
                message = list(self.socket.recv(flags=zmq.NOBLOCK))[0]
            except zmq.error.Again:
                continue

            if message == to_replace:
                count = count + 1

            #  Send reply back to client
            self.socket.send_string(str(message))

        output_file = open("files_sache/truth.ll", 'w')
        output_file.write(p.stdout.read())

        return count

    # Changes the nth occurence of to_replace in the given command to change_to
    #
    # returns true if the modification was successful
    def replace_nth_occurence(self, cmd: str, to_replace: int,
                              modify_index: int, change_to: int) -> bool:

        print(cmd + [" replacing occurences!"])
        p = Popen(cmd, stdin=PIPE, stdout=PIPE, text=True)
        index = 0

        while p.poll() is None:
            try:
                #  Wait for next request from client
                message = list(self.socket.recv(flags=zmq.NOBLOCK))[0]
            except zmq.error.Again:
                continue

            print(index)
            #  Send reply back to client
            if message == to_replace and index == modify_index:
                print("replaced")
                self.socket.send_string(str(change_to))
            else:
                self.socket.send_string(str(message))

            if message == to_replace:
                index = index + 1

        output_file = open("files_sache/file" + str(modify_index) + ".ll", 'w')
        output_file.write(p.stdout.read())

        return True

    # Changes the nth occurence of MayAlias in the given command to change_to
    #
    # Returns true if the modification was successful
    #
    # change_to is 0 for NoAlias, 1 for MusAlias, 2 for PartialAlias, 3 for
    # MayAlias
    def execute_with_modifications(self, cmd: list[str], modify_index: int,
                                   change_to: int) -> bool:
        return self.replace_nth_occurence(cmd, "MayAlias", modify_index,
                                          change_to)

    def compile_file(self, index: int) -> bool:
        cmd = [
            self.args.compilerpath, "files_sache/file" + str(index) + ".ll",
            '-o', "files_sache/file" + str(index) + ".out"
        ]
        print(cmd)
        p = run(cmd, stdout=DEVNULL, stderr=DEVNULL, text=True)
        return p.returncode == 0

    def measure_outputsize(self, file: str) -> int:
        cmd = ['llvm-size', file]
        print(cmd)
        p = run(cmd, stdout=PIPE, stderr=PIPE, text=True)
        if p.stderr != "":
            print(p.stderr)
            return -1
        second_line = p.stdout.split("\n")[1]
        line_list = second_line.split("\t")
        # The other results are more info on where size is: test, data, bss
        return int(line_list[3])

    # Changes the first alias queries to alias_results
    #
    # Afterwards, all other alias queries are changed to default
    #
    # if default is -1, the query stays the same
    def compile_with_list(self,
                          cmd: list[str],
                          alias_results: list[int],
                          output_file_name: str,
                          default: int = 3) -> bool:
        print(cmd + [" list-based!"])
        p = Popen(cmd, stdin=PIPE, stdout=PIPE, text=True)
        line = p.stdout.readline().strip()
        index = 0
        while not line.startswith("; ModuleID"):
            if line.startswith("Failed"):
                return False

            curr_result = self.get_result_from_output(line)

            if index < len(alias_results):
                p.stdin.write(str(alias_results[index]) + "\n")
            elif default == -1:
                self.give_same_result(p, curr_result)
            else:
                p.stdin.write(str(default) + "\n")
            index = index + 1

            p.stdin.flush()
            line = p.stdout.readline().strip()

        output_file = open(output_file_name, 'w')
        while line != "":
            line = p.stdout.readline()
            output_file.write(line)

        return True



if __name__ == "__main__":
    InteractiveAliasAnalysisDriver().run()
